<html>
<head>
  <title> Jessica's ASSIGNMENT 2 </title>
  <link rel="stylesheet" type="text/css" href="assignment2.css">
  </head>
  <body>
    <h2> ASSIGNMENT 2 - Will come up with a cooler name later </h2>

<button class="button">Styled Button</button>
  <canvas id="testCanvas" width="1000" height="1000">

  </canvas>
  </body>

  <script>


  window.onload = function(){

let canvas = document.getElementById('testCanvas');
let canvasContext = canvas.getContext('2d');
const MAX_ELLIPSES =10;
const MAX_RECT = 10;

//event listerer
canvas.addEventListener("mousedown",function(event){
  console.log("canvas mouse clicked"); //part ONE
  for(let i=0; i<MAX_RECT; i++){
    myRect[i].hitTest(event);
}
});

canvas.addEventListener("mousemove",function(event){
  console.log("mouse was moved"); //part ONE
  for(let i=0; i<MAX_RECT; i++){
    myRect[i].hitTestOver(event); //knows that a shape was clicked
  }

});

//array
let myEllipses = [];
let myRect = [];

let colors = [];
colors.push(new colorObject(217,179,255)); //purple
colors.push(new colorObject(255,179,217)); //pink
colors.push(new colorObject(100,100,128)); //yellow
colors.push(new colorObject(204,255,179)); //green
colors.push(new colorObject(255,224,179)); //orange
colors.push(new colorObject(179,198,255)); //blue
colors.push(new colorObject(255,179,179)); //red
colors.push(new colorObject(255,179,247)); //mangatia
colors.push(new colorObject(185,249,203)); //lime green
colors.push(new colorObject(247,187,204)); //light pink





function colorObject(r,g,b){
  this.r =r;
  this.g =g;
  this.b = b;
  this.a =1.0;

}


//start of arrays
for (let i =0; i< MAX_ELLIPSES;i++){

// A REMINDER - i = x-axis, i = y-axis 15 = size of ball, color , (i%3)+9, (i%8)+7 = speed of ball
  myEllipses.push(new myRunningEllipse(i,i,27,colors[i%colors.length],(i%3)+7,(i%4)+5));
}

for (let i =0; i< MAX_RECT;i++){
// A REMINDER - i+100 = x-axis, i+100 = y-axis 30,30 = w &h of rect, color , (i%5)+1,(i%2)+5) = speed of rect
  myRect.push(new myRunningRect(i,i,60,60,colors[i%colors.length],(i%3)+2,(i%4)+1,i));

}

requestAnimationFrame(runAni);

// this is our callback function (to simulate a loop ... )
function runAni(){


  canvasContext.clearRect(0, 0, canvas.width, canvas.height);


  for (let i =0; i< MAX_ELLIPSES;i++){
    myEllipses[i].update();
    myEllipses[i].render();

  }

  for (let i =0; i< MAX_RECT;i++){
    myRect[i].update();
    myRect[i].render();

  }
  // recursive call ...
  requestAnimationFrame(runAni);
}

//start of circle function
function myRunningEllipse(x,y,r,c,xSpeed,ySpeed){
  //member variables
  this.xPos = x;
  this.yPos = y;
  this.radius = r;

//color for ball
  this.r =c.r;
  this.g =c.g;
  this.b=c.b;
  this.a=c.a;

  // new for updating
  this.xSpeed = xSpeed;
  this.ySpeed =ySpeed;

//member function
  this.render =function(){
    this.ellipseColor= "rgba("+this.r+","+this.g+","+this.b+","+this.a+")";
      canvasContext.fillStyle = this.ellipseColor;// change the color we are using
      canvasContext.beginPath();
      canvasContext.arc(this.xPos,this.yPos,this.radius,0, Math.PI * 2, true);
      canvasContext.fill(); // set the fill
      canvasContext.closePath(); //close a path ...
    }
  //member function for updating
  this.update = function(){
       if(this.xPos<0 || this.xPos>canvas.width){
         this.xSpeed*=-1;
       }
       if(this.yPos<0 || this.yPos>canvas.height){
         this.ySpeed*=-1;
       }
       this.xPos+=this.xSpeed;
       this.yPos+=this.ySpeed;
     }
  } // end of circle FUNCTION

//start of rect FUNCTION
  function myRunningRect(x, y, w, h, c, xSpeed,ySpeed,eid) {
      this.x = x;
      this.y = y;
      this.w = w;
      this.h = h;
      this.isOver=false;

      this.eID = eid;

      //color of rect
      this.r =c.r;
      this.g =c.g;
      this.b=c.b;
      this.a=c.a;


      this.xSpeed = xSpeed;
      this.ySpeed =ySpeed;

      this.render = function(){
         if(this.isOver ===true){
           console.log(this.a);
           this.a = this.a - 0.1;
         }



          this.rectColor= "rgba("+this.r+","+this.g+","+this.b+","+this.a+")";
          canvasContext.fillStyle = this.rectColor;
          canvasContext.fillRect(this.x,this.y,this.w, this.h);

        }

        this.update = function(){
             if(this.x<0 || this.x>canvas.width){
               this.xSpeed*=-1;
             }
             if(this.y<0 || this.y>canvas.height){
               this.ySpeed*=-1;
             }
             this.x+=this.xSpeed;
             this.y+=this.ySpeed;
           }

//event listerner
           this.hitTest = function(event){
             if(Math.sqrt(Math.pow((event.clientX-this.x),2)+Math.pow((event.clientY-this.y),2))<this.w/2){
               //console.log("rect Pressed::: " + this.eID);
               this.isPressed = !this.Pressed;

             }
           }

           // FADE
               this.hitTestOver = function(event){

                //need 3 lines of code becasue the canava was not at (0,0)
                 let c = canvas.getBoundingClientRect();
                 let mouseY = event.clientY -c.top;
                 let mouseX = event.clientX -c.left;

                 //console.log(Math.sqrt(Math.pow((event.clientX-this.x),2)+Math.pow((event.clientY-this.y),2)));
                 if(Math.sqrt(Math.pow((mouseX-this.x),2)+Math.pow((mouseY-this.y),2))<this.w/2){
                   console.log("rect over::: " + this.eID);
                   //this.a -=0.01;
                   this.isOver=true;
                 }
                 else{
                   this.isOver = false;
                 }


                 }

    } //END OF RECT FUNCTION
} //end window onload - EVERYTHING HAS TO BE INSIDE OF HERE
  </script>


</html>
